import fs from 'fs';
import express from 'express';
import bodyParser from 'body-parser';
import cors from 'cors';
import sdic from 'sdic';
import Busboy from 'busboy';
import randomstring from 'randomstring';
import createSlug from 'slug';

const container = sdic.create();
container.load('./config');
container.load('./lib', { alias: null });
container.load('./repository');
container.load('./middleware');
container.load('./errors', { isConstructor: true });
container.load('./routes');
container.register('app', (config) => {
  const app = express();

  // Catch URIError: Failed to decode param '...'.
  // Note: It is generated by a external robots during penetration tests.
  app.use((req, res, next) => {
    try {
      decodeURIComponent(req.path);
    } catch (err) {
      return res.status(400).end('URIError: Failed to decode param');
    }

    return next();
  });

  // allow all
  app.use(cors());

  // Transform the request with urlencoded body into javascript object
  app.use(bodyParser.urlencoded({ extended: true }));

  // Transform the request with JSON styled body into javascript object
  app.use(bodyParser.json());

  // parse multipart/form-data
  app.use((req, res, next) => {
    req.files = req.files || [];

    if (!/multipart\/form-data/.test(req.headers['content-type'])) {
      next();
      return;
    }

    const busboy = new Busboy({ headers: req.headers });

    // extract form fields
    busboy.on('field', (key, val) => {
      try {
        req.body[key] = JSON.parse(val);
      } catch (e) {
        console.log('Failed to parse', key, ':', val); // eslint-disable-line
      }
    });

    // upload files
    let currentFilename = null;
    busboy.on('file', (field, file, filename, encoding, mimeType) => {
      const uploadedFilename = createSlug(`${randomstring.generate(7)}-${filename}`, { lower: true, charmap: { '.': '-_-' } }).replace('-_-', '.');
      currentFilename = uploadedFilename;
      const uploadStream = fs.createWriteStream(config.createUploadPath(uploadedFilename));

      uploadStream.on('error', (e) => {
        // todo: custom error
        next(e);
        req.destroy();
      });

      req.files.push({
        filename: uploadedFilename,
        originalName: filename,
        encoding,
        mimeType
      });

      file.pipe(uploadStream);
    });

    busboy.on('error', next);
    busboy.on('finish', next);

    req.on('aborted', () => {
      req.files = [];
      if (currentFilename !== null) {
        try {
          fs.unlinkSync(config.createUploadPath(currentFilename));
        } catch (e) {
          console.log('Failed to remove aborted upload', config.createUploadPath(currentFilename)); // eslint-disable-line
        }
      }
    });

    req.on('end', () => {
      currentFilename = null;
    });

    req.pipe(busboy);
  });

  // append uploaded file size (not available during upload because busboy closes stream before write stream(s) ends)
  app.use((req, res, next) => {
    if (!(req.files && req.files.length)) {
      next();
      return;
    }

    req.files = req.files.map((file) => {
      const stats = fs.statSync(config.createUploadPath(file.filename));
      return { ...file, size: stats.size };
    });

    next();
  });

  // Merge body and query into req.data
  app.use((req, res, next) => {
    req.data = { ...req.query, ...req.body };
    next();
  });

  return app;
});

export default container;
